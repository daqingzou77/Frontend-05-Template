学习笔记-week01

内容一：实现一个三子棋游戏

从讲解游戏规则到代码实现经历以下一个步骤：

1.创建棋盘，从最开始采用二维数组到使用一维数组降维去迭代实现，这里的用到小技巧在于：利用数组
坐标同余特性，可以用数组下标：i*arr.length + j 的方法去找到一维数组对应的二维平面的位置，降维带来的直接收益是有效的节省内存空间

winter老师使用的show()函数，每次对弈时，需要重新调用函数，完成棋盘更新，并且绑定点击事件

2.双方对战。这里需要对用户每次落子后的对局情况进行判断，这里用check函数得出胜负结果，由于是三子棋，判断优胜的条件较少，代码比较容易实现，主要考虑：横、纵、斜三个方向是否有出现连子的情况，若存在三子连线则单方获胜，否则游戏继续

3.willWin函数用于判断是否有即将胜出的玩家，这赋予三子棋对战一个基础AI的功能，这里由于使用一维数组表示棋盘，可采用Object.create()的方法克隆棋盘数组。这里需要考虑深浅拷贝的问题。原因是二维数组中存储的元素是引用数据类型，浅拷贝的值会指向堆中同一片内存空间，改变克隆数组的值将影响原始数组。

这里将二维数组降为一维后，数组中都存储基本的数据类型，可采用Object.create方法对原数组进行值克隆，并且create方法可以用参数对象作为新输出对象的原型，更加友好的替代JSON.parse(JSON.stringify())的克隆对象的方法。


4.bestChoice选择落子最优解，通过递归得到最优选择。

这里如何通过递归的方式取得最优解的过程，我还没有完全搞清楚原理是咋回事，我后期会找些递归的题目多做练习，巩固这方面知识。

对于winter老师留了optional的作业，我暂时没有很好的思路去实现。。


内容二：异步编程

这里主要是一个经典的红绿灯定时任务，该问题也考察了JS中几大异步编程方案。

对于JS语言本身是单线程的执行模型，所以在遇到定时任务、网络请求、事件回调等问题时，因为同步代码阻塞，所以需要通过异步的方式去处理。

这里老师主要带我们回顾了几个经典的异步编程模式：回调函数、Promise、Generator/yield、async/await

    
此外：我还看了重学前端中，JS板块的前五节内容。

第一节：提问方式由浅入深的了解JS中数据类型。JS七大数据类型、类型转化的问题、稍微复杂的StringToNumber和NumberToString以及装箱和拆箱操作

第二节：讨论JS究竟是面向对象还是基于对象的语言。首先面向对象概念中对象特性主要有:唯一性、具有状态和行为。从而可以看出，JS是一门面向对象的语言，并且在JS中，对象是一个高度动态性的属性集合，主要分为数据属性和访问器属性。

第三节：初识原型。原型系统的设计思路：并不真的复制一个原型对象，而是使得新对象持有原型的引用。原型系统：所有对象都有私有字段[[prototype]],就是对象的原型；访问对象的属性时，会查询对象的原型链，直至为空。了解ES6中的class类。

第四节：对象的分类：宿主、内置（固有对象、原生对象、普通对象），深入函数对象以及构造器对象、模拟行为的对象

第五节：主要从宏任务与微任务的底层原理分析为何Promise代码块会优先于setTimeout执行，认识async/await


流程框架图，后期补上

    
最后，谈谈上课的感受把：老师授课水平还是蛮高的，对于有些问题，我暂时还存有一些困惑，我想我会持之以恒地去学习，并会时常看看以往做过的练习，查缺补漏，希望自己能够在前端进阶地课程有效地拔高自己~~加油！


       